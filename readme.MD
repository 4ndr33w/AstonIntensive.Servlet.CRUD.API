## Aston Intensive HW 2. Servlet JDBC CRUD API

### Описание проекта

Проект представляет REST API на основе сервлетов и JDBC.
Предоставляет как стандартный набор CRUD-операций, 
так и расширенные возможности 
с организацией связи ManyToMany
на основе двух таблиц: Projects и Users

- используются не PathVariable, составляющие часть пути к запросу, а передаваемые параметры (query params)


- По эндпойнту /api/v1/users происходит создание, удаление, редактирование двнных пользователя
(используется строковой параметр 'id'), а также запрос информации о пользователе (по 'id')


- По эндпойнту /api/v1/projects происходит создание, удаление, редактирование двнных проекта
  (так же используется строковой параметр 'id'), а также запрос информации о проекте (по 'id' проекта)

### Организована связь Many To Many

- Каждый пользователь может принимать участие в многих проектах; 
- К каждому проекту может присоединиться множество пользователей.

Для организации взаимосвязи добавлена вспомогательная таблица project_users,
содержащая user_id и project_id (составной Primary key на основе этих двух столбцов)

- По эндпойнту /api/v1/users/all получаем список всех пользователей, В полученном списке внутри каждого объекта User 
содержится коллекция DTO проектов, в которых пользователь
принимает участие, а также, каждый DTO проекта с коллекцию Id пользователей-участников проекта.

### Организована связь One To Many

- По эндпойнту /api/v1/projects/user по передаваемому в адресной строке параметру 'id' 
получаем коллекцию проектов, в которых принимает участие пользователь;


- По эндпойнту /api/v1/projects/admin получаем коллекцию проектов, в которых пользователь является администратором (создателем проекта),
так же, на основании переданного 'id'

### Добавление / удаленик пользователя в / из проекта

- По эндпойнту /api/v1/projects/users методами POST и DELETE добавление / удаление пользователя:
в адресной строке передаются два параметра - userid и projectid, которые заносятся во вспомогательную таблицу project_users

### Дополнительно 

Запросы из сервлетов в контроллеры и далее передаются в отдельных потоках,
созданными через ExecutorServices;

Используется асинхронный контекст запроса: AsyncContext asyncContext = req.startAsync();

В репозиториях формируется ответ из базы данных и упаковывается в CompletableFuture;

В сервисе внутри CompletableFuture составляются объекты: List<User> или List<Project>
со связями OneToMany: каждому пользователю добавляются загруженные из слоя репозитория проекты, 
либо к проектам добавляются загруженные из слоя репозитория пользователи;

Тут же, в слое сервиса, идёт преобразование в Dto: чтобы контроллер занимался только переадресацией запросов от сервлетов к сервисам,
а в сервлеты уже приходило готовое Dto, которое необходимо только распаковать из CompletableFuture, оформить в Json и отобразить

### Но

Создание потоков пока не привязано к сессии - для этого необходимо сначала "присобачить" аутенфикацию и авторизацию.

Создание потоков привязано к вызову метода сервлета по Endpoint'у

### P. S.

- Перелопатил весь код; тесты надо будет писать заново:
- Удалил все однопоточные версии контроллеров-сервисов-репозиториев;
- все Sql-запросы теперь идут через PreparedStatement;
- Для уменьшения количества Sql-запросов при выводе списка пользователей (с проектами) / проектов (с пользователями)
сначала сервис запрашивает тремя отдельными запросами: список пользователей по списку Id; список ProjectUser; список проектов по набору id,
а потом составляется композиция из уже загруженных данных, а не запрашивается по одной строке из БД для каждого элемента;
- Задокументировано пока так же не полностью.